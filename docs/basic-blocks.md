Basic Blocks
============
A basic block is an abstraction over a maximal sequence of instructions that end
in a control-flow transfer instruction. In Granary, all unconditional control-flow
transfer instructions except for `call` terminate basic blocks. Conditional
control-flow transfers do not terminate basic blocks (unless configured otherwise)
as their fall-through path is straight-line code.

See 
[control flow](control-flow.md) for more information about how control-flow
transfers are handled by Granary.

In Granary, a basic block data structure contain three components, and is only
reified /after/ the block has been emitted to the [code cache](code-cache.md).

1.  Virtual table.
2.  Block-local storage.
3.  x86 instructions.
4.  Meta information.

1. Virtual table
-----------------
Granary uses a variable-length virtual table for certain direct calls and jumps,
as well as all indirect calls and jumps. The virtual table is emitted before the
basic block structure, and is in principle part of the basic block. In practice,
once emitted, the vtable is "hidden" from the programmer.

In the case of direct calls/jumps, a vtable slot is used if the target instruction
is over 4GB away from the encoded instruction. The vtable slot acts as a constant
storage location for the target address, and a different encoding is used.

2. Block-local Storage
----------------------
Block-local storage is used by Granary clients to store per-basic block
information that can be modified by the instructions within that basic block.
Block-local storage is useful for implementing, among other things, performance
counters.

Block-local storage is defined in `granary/state.h` and extended by client code
in `clients/state.h`. There are two block-local storage data structures: 
`granary::basic_block_state` and `client::basic_block_state`. The former extends
the latter. As a result, changing `client::basic_block_state` implicitly
changes `granary::basic_block_state`. The implication of client extension of
basic block storage is that this form of storage is /only/ available to
translated code: code that is directly generated by Granary for internal uses
(e.g. branch lookup) does not contain block local storage.

Granary ensures that `granary::basic_block_state` is aligned on a 16-byte
boundary and is emitted before [1] any instructions. This placement was
motivated by the ease with which `%rip`-relative addressing emitting code in a
single pass could be performed. That is, when translating a new basic block,
Granary will stage the block in a region of memory that is large enough to
hold the final emitted basic block. As a result, the exact pointer to the basic
block storage can be given to the client for modification and use.

[1] Block-local storage is emitted before instructions insofar as it is
    allocated before the instructions of a basic block are allocated. Tying
    allocation of basic blocks to instructions means that space must be pre-
    allocated for a basic block before client code has a chance to instrument
    the block. If client code injects an arbitrary number of instructions (that
    potentially use block local storage), and the updated size of the basic block
    exceeds the allocated size, then the block might need to be re-instrumented.
    This unnecessary work is avoided by doing separate allocation.

3. x86 Instructions
-------------------
Granary uses DynamoRIO's instruction representation and encoder to translate
and emit instructions into the code cache. Each instruction in a basic block
has one of four states: padding, native, instrumented, and mangled.

A padding instruction is an int3 and should never be executed. A native
instruction should (but this can be subverted) directly map to an instruction
in module/application code. An instrumented instruction is one that client code
has injected and that has no direct correspondence with any native instructions.
Finally, a mangled instruction is one that is internally generated by Granary
for branch lookup, etc.

Granary ensures that there is only one mangled instruction per translated
basic block, i.e. the instruction that terminates the basic block.

4. Meta Information
-------------------
After the instructions, there is a variable-sized data structure representing
meta-information about each basic block. Meta information is aligned on a 16
byte boundary and includes:

1.  A 3-byte "magic" number.
2.  A one byte tag representing the kind of the basic block. Each kind of basic
    block has different semantics under interrupts.
3.  A "hotness" counter. The hotness counter is intended to be an interrupt
    performance counter.
4.  The number of bytes of instruction code and instruction padding code there
    is. This number of bytes allows us to efficiently calculate the location of
    any block-local storage (if any), as well as the size of the instruction
    byte state set (see below).
5.  The "generating" pc. If this is non-null then this is the native program
    counter that, when translated, generated this basic block.

Immediately following the meta information--although not explicitly represented
in the `basic_block_info` struct--is a bitset representing the state of every
instruction byte in the basic block. The bitset maps each byte of instructions
to two bits of state. The states record the kind of instruction of each byte of
instructions.

This meta information is used when a basic block is [interrupted](interrupts-exceptions.md).
 